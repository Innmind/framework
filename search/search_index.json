{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Framework","text":"<p>The philosophy behind this framework is to have a minimalist foundation to be able to build simple apps but can also accomodate for more complex applications through composition (of the configuration, commands, request handlers and more).</p> <p>Another important design is to expose to you the input to handle and an abstraction of the operating system it runs on so you only need to focus on what your app needs to do and not how.</p>"},{"location":"cli/","title":"Build a CLI app","text":"<p>The first of any CLI app is to create an <code>entrypoint.php</code> that you'll call with the <code>php</code> command.</p> entrypoint.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/composer/autoload.php';\n\nuse Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n};\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app;\n    }\n};\n</code></pre> <p>By default this application will write <code>Hello world</code> when you call <code>php entrypoint.php</code>.</p>"},{"location":"cli/#handle-commands","title":"Handle commands","text":"<p>This example reuses the AMQP clients defined in the services section.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n};\nuse Innmind\\CLI\\{\n    Console,\n    Command,\n    Command\\Usage,\n};\nuse Innmind\\DI\\{\n    Container,\n    Service,\n};\nuse Innmind\\AMQP\\{\n    Client,\n    Command\\Publish,\n    Command\\Get,\n    Model\\Basic\\Message,\n};\nuse Innmind\\Immutable\\{\n    Attempt,\n    Str,\n};\n\nenum Services implements Service\n{\n    case producerClient;\n    case consumerClient;\n}\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;service(Services::producerClient, /* see services section */)\n            -&gt;service(Services::consumerClient, /* see services section */)\n            -&gt;command(static fn(Container $container) =&gt; new class($container(Services::producerClient)) implements Command {\n                public function __construct(\n                    private Client $amqp,\n                ) {\n                }\n\n                public function __invoke(Console $console): Attempt\n                {\n                    $message = Message::of(Str::of(\n                        $console-&gt;arguments()-&gt;get('url'),\n                    ));\n\n                    return $this\n                        -&gt;client\n                        -&gt;with(Publish::one($message)-&gt;to('some-exchange'))\n                        -&gt;run($console)\n                        -&gt;flatMap(static fn($console) =&gt; $console-&gt;output(\n                            Str::of(\"Message published\\n\"),\n                        ))\n                        -&gt;recover(static fn() =&gt; $console-&gt;error(\n                            Str::of(\"Something went wrong\\n\"),\n                        ));\n                }\n\n                public function usage(): Usage\n                {\n                    return Usage::of('publish')-&gt;argument('url');\n                }\n            })\n            -&gt;command(static fn(Container $container) =&gt; new class($container(Services::consumerClient)) implements Command {\n                public function __construct(\n                    private Client $amqp,\n                ) {\n                }\n\n                public function __invoke(Console $console): Attempt\n                {\n                    return $this\n                        -&gt;client\n                        -&gt;with(Get::of('some-queue'))\n                        -&gt;run($console)\n                        -&gt;flatMap(static fn($console) =&gt; $console-&gt;output(\n                            Str::of(\"One message pulled from queue\\n\"),\n                        ))\n                        -&gt;recover(static fn() =&gt; $console-&gt;error(\n                            Str::of(\"Something went wrong\\n\"),\n                        ));\n                }\n\n                public function usage(): Usage\n                {\n                    return Usage::of('consume');\n                }\n            });\n    }\n};\n</code></pre> <p>This example creates 2 commands <code>publish</code> (that expect one argument) and <code>consume</code>. Each command relies on a service to access the AMQP client.</p> <p>You can call <code>php entrypoint.php publish https://github.com</code> that will call the first command and <code>php entrypoint.php consume</code> will call the second one.</p>"},{"location":"cli/#execute-code-on-any-command","title":"Execute code on any command","text":"<p>Sometimes you want to execute some code on every command. So far your only approach would be to use inheritance on each <code>Command</code> but this leads to bloated code.</p> <p>Fortunately there is better approach: composition of <code>Command</code>s.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n};\nuse Innmind\\CLI\\{\n    Console,\n    Command,\n    Command\\Usage,\n};\nuse Innmind\\Immutable\\Attempt;\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;mapCommand(\n                static fn(Command $command) =&gt; new class($command) implements Command {\n                    public function __construct(\n                        private Command $inner,\n                    ) {\n                    }\n\n                    public function __invoke(Console $console): Attempt\n                    {\n                        // do something before the real command\n\n                        return ($this-&gt;inner)($console);\n                    }\n\n                    public function usage(): Usage\n                    {\n                        return $this-&gt;inner-&gt;usage();\n                    }\n                }\n            )\n            -&gt;service(/* ... */)\n            -&gt;service(/* ... */)\n            -&gt;command(/* ... */)\n            -&gt;command(/* ... */);\n    }\n};\n</code></pre>"},{"location":"environment/","title":"Add variables to the environment","text":"<p>The framework exposes an <code>Environment</code> object with values coming from <code>\\getenv()</code>. If you want to add variables and make them available to the rest of your application you can do it like this:</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Main\\Http,\n    Application,\n    Environment,\n};\n\nnew class extends Http|Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;mapEnvironment(\n            static fn(Environment $env) =&gt; $env-&gt;with(\n                'MY_VARIABLE_NAME',\n                \"and it's value\",\n            ),\n        );\n    }\n};\n</code></pre>"},{"location":"environment/#loading-a-env-file","title":"Loading a <code>.env</code> file","text":"<p>A common pattern is to put all your environment variables inside a <code>.env</code> file. The framework comes with a middleware to do just that.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Main\\Http,\n    Application,\n    Middleware\\LoadDotEnv,\n};\nuse Innmind\\Url\\Path;\n\nnew class extends Http|Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;map(LoadDotEnv::at(Path::of('somewhere/in/your/app/')));\n    }\n};\n</code></pre> <p>The path represents the folder containing the <code>.env</code> file (and the path must end with <code>/</code>).</p> <p>The <code>.env</code> file itself must contain one variable per line with the format <code>NAME=value</code>. Everything after <code>=</code> is considered the value to avoid complex parsing. Empty lines or lines starting with <code>#</code> are ignored.</p>"},{"location":"http-and-cli/","title":"Build an app that runs through HTTP and CLI","text":"<p>If you looked at how to build an HTTP and CLI apps you may have noticed that we always configure the same <code>Application</code> class. This is intentional to allow you to configure services once (in a middleware) and use them in both contexts.</p> <p>Let's take an imaginary app where you can upload images via HTTP (persists them to the filesystem) and a CLI command that pulls a message from an AMQP queue to build the thumbnail. We would build a middleware that roughly looks like this:</p> <pre><code>use Innmind\\Framework\\{\n    Application,\n    Middleware,\n    Http\\Route,\n};\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\DI\\{\n    Container,\n    Service,\n};\nuse Innmind\\Url\\Path;\n\nenum Services implements Service\n{\n    case images;\n    case amqp;\n    case upload;\n}\n\nfinal class Kernel implements Middleware\n{\n    public function __invoke(Application $app): Application\n    {\n        return $app\n            -&gt;service(\n                Services::images,\n                static fn($_, OperatingSystem $os) =&gt; $os\n                    -&gt;filesystem()\n                    -&gt;mount(Path::of('somewhere/on/the/filesystem/'))\n                    -&gt;unwrap(),\n            )\n            -&gt;service(Services::amqp, /* see services section */)\n            -&gt;service(Services::upload, static fn(Container $container) =&gt; new UploadHandler( //(1)\n                $container(Services::images),\n                $container(Services::amqp),\n            ))\n            -&gt;route(Route::post(\n                '/upload',\n                Services::upload,\n            ))\n            -&gt;command(static fn(Container $container) =&gt; new ThumbnailWorker( //(2)\n                $container(Services::images),\n                $container(Services::amqp),\n            ));\n    }\n}\n</code></pre> <ol> <li>imaginary class</li> <li>imaginary class</li> </ol> <p>Then you can use this middleware like this:</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n};\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;map(new Kernel);\n    }\n}\n</code></pre> <p>Or like this:</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;map(new Kernel);\n    }\n}\n</code></pre> <p>In the case on the CLI the call to <code>route</code> will have no effect and for HTTP <code>command</code> will have no effect.</p>"},{"location":"http/","title":"Build an HTTP app","text":"<p>The first of any HTTP app is to create an <code>index.php</code> that will be exposed via a web server.</p> index.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/composer/autoload.php';\n\nuse Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app;\n    }\n};\n</code></pre> <p>By default this application will respond with <code>404 Not Found</code> on any incoming request.</p>"},{"location":"http/#handle-routes","title":"Handle routes","text":"<pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n    Http\\Route,\n};\nuse Innmind\\DI\\Service;\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n    Response\\StatusCode,\n};\nuse Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Immutable\\Attempt;\n\nenum Services implements Service\n{\n    case hello;\n}\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;service(Services::hello, static fn() =&gt; static fn(\n                ServerRequest $request,\n                ?string $name = null,\n            ) =&gt; Attempt::result(Response::of(\n                StatusCode::ok,\n                $request-&gt;protocolVersion(),\n                null,\n                Content::ofString(\\sprintf(\n                    'Hello %s!',\n                    $name ?? 'world',\n                )),\n            )))\n            -&gt;route(Route::get(\n                '/',\n                Services::hello,\n            ))\n            -&gt;route(Route::get(\n                '/{name}',\n                Services::hello,\n            ));\n    }\n};\n</code></pre> <p>This example defines 2 routes both accessible via a <code>GET</code> method. When called, a route will be handled by the <code>Services::hello</code> service.</p> <p>For simplicity here the route handler is defined as a <code>Closure</code> but you can use objects instead.</p>"},{"location":"http/#multiple-methods-for-the-same-path","title":"Multiple methods for the same path","text":"<p>For REST apis it is common to implements differents methods for the same path in a CRUD like fashion. To avoid duplicating the template for each route you can regroup your routes like this:</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\nuse Innmind\\DI\\Container;\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n    Response\\StatusCode,\n};\nuse Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Immutable\\Attempt;\n\nenum Services implements Service\n{\n    case get;\n    case delete;\n}\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;service(\n                Services::get,\n                static fn() =&gt; static fn(ServerRequest $request) =&gt; Attempt::result(\n                    Response::of(\n                        StatusCode::ok,\n                        $request-&gt;protocolVersion(),\n                        null,\n                        Content::ofString('{\"id\": 42, \"name\": \"resource\"}'),\n                    ),\n                ),\n            )\n            -&gt;service(\n                Services::delete,\n                static fn() =&gt; static fn(ServerRequest $request) =&gt; Attempt::result(\n                    Response::of(\n                        StatusCode::noContent,\n                        $request-&gt;protocolVersion(),\n                    ),\n                ),\n            )\n            -&gt;route(\n                static fn(Pipe $pipe, Container $container) =&gt; $pipe\n                    -&gt;endpoint('/some/resource/{id}')\n                    -&gt;any(\n                        $pipe\n                            -&gt;forward()\n                            -&gt;get()\n                            -&gt;spread()\n                            -&gt;handle($container(Services::get))),\n                        $pipe\n                            -&gt;forward()\n                            -&gt;delete()\n                            -&gt;spread()\n                            -&gt;handle($container(Services::delete))),\n                    ),\n            );\n    }\n};\n</code></pre> <p>The other advantage to grouping your routes this way is that when a request matches the path but no method is defined then the framework will automatically respond a <code>405 Method Not Allowed</code>.</p>"},{"location":"http/#executing-code-on-any-route","title":"Executing code on any route","text":"<p>Sometimes you want to execute some code on every route (like verifying the request is authenticated).</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\nuse Innmind\\Router\\Component;\nuse Innmind\\Http\\Message\\{\n    ServerRequest,\n    Response,\n    Response\\StatusCode,\n};\nuse Innmind\\Immutable\\Attempt;\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;mapRoute(\n                static fn(Component $route) =&gt; Component::of(static function(\n                    ServerRequest $request,\n                    mixed $input,\n                ) {\n                    // use something stronger in a real app\n                    if (!$request-&gt;headers()-&gt;contains('authorization')) {\n                        return Attempt::error(new \\RuntimeException('Missing authentication'));\n                    }\n\n                    return Attempt::result($input); #(1)\n                })-&gt;pipe($route),\n            )\n            -&gt;service(/* ... */)\n            -&gt;service(/* ... */)\n            -&gt;route(/* ... */)\n            -&gt;route(/* ... */);\n    }\n};\n</code></pre> <ol> <li>You can replace <code>$input</code> with the authenticated user, this variable will be carried to the next route component.</li> </ol> <p>This example will refuse any request that doesn't have an <code>Authorization</code> header. Assuming you use a service instead of an inline component, you can disable a behaviour across your entire app by removing the one line calling <code>mapRoute</code>.</p> <p>You can have multiple calls to <code>mapRoute</code> to compose behaviours like an onion.</p>"},{"location":"http/#handling-unknown-routes","title":"Handling unknown routes","text":"<p>Sometimes a user can mispell a route or use an old route that no longer exist resulting in a <code>404 Not Found</code>. For APIs this can be enough but you may want to customize such response.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Application,\n};\nuse Innmind\\Http\\Message\\{\n    ServerRequest,\n    Response,\n    Response\\StatusCode,\n};\nuse Innmind\\Filesystem\\File\\Content;\nuse Innmind\\Immutable\\Attempt;\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;routeNotFound(\n            static fn(ServerRequest $request) =&gt; Attempt::result(Response::of(\n                StatusCode::notFound,\n                $request-&gt;protocolVersion(),\n                null,\n                Content::ofString('Page Not Found!'), //(1)\n            )),\n        );\n    }\n};\n</code></pre> <ol> <li>or return something more elaborated such as html</li> </ol>"},{"location":"middlewares/","title":"Middlewares","text":"<p>Middlewares are a way to regroup all the configuration you've seen in other sections under a name. This means that you can either group part of your own application under a middleware or expose a package for other to use via Packagist.</p> <p>You can search for <code>innmind/framework-middlewares</code> on Packagist for middlewares published by others.</p> <p>Let's say you have an application that sends emails you could have a middleware that looks like this:</p> <pre><code>use Innmind\\Framework\\{\n    Middleware,\n    Environment,\n};\nuse Innmind\\DI\\{\n    Container,\n    Service,\n};\nuse Innmind\\CLI\\{\n    Console,\n    Command,\n    Command\\Usage,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\{\n    Attempt,\n    Str,\n};\n\nenum Services implements Service\n{\n    case emailServer;\n}\n\nfinal class Emails implements Middleware\n{\n    public function __construct(\n        private Service $service,\n    ){\n    }\n\n    public function __invoke(Application $app): Application\n    {\n        return $app\n            -&gt;service(\n                Services::emailServer\n                static fn($_, $__, Environment $env) =&gt; Url::of(\n                    $env-&gt;get('EMAIL_SERVER'),\n                ),\n            ),\n            -&gt;service(\n                $this-&gt;service,\n                static fn(Container $container) =&gt; new EmailClient( //(1)\n                    $container(Services::emailServer),\n                ),\n            )\n            -&gt;command(\n                fn(Container $container) =&gt; new class($container($this-&gt;service)) implements Command {\n                    public function __construct(\n                        private EmailClient $client,\n                    ) {\n                    }\n\n                    public function __invoke(Console $console): Attempt\n                    {\n                        // send a test email here for example\n\n                        return $console-&gt;output(Str::of('Email sent'));\n                    }\n\n                    public function usage(): Usage\n                    {\n                        return Usage::of('email:test');\n                    }\n                }\n            );\n    }\n}\n</code></pre> <ol> <li>imaginary class</li> </ol> <p>And you would use it like this:</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n};\n\nenum MyServices implements Service\n{\n    case emailClient;\n}\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;map(new Emails(MyServices::emailClient));\n    }\n};\n</code></pre> <p>This example defines 2 services and a command and let the end users choose the name of the email client service so they can reuse it in their applications.</p>"},{"location":"middlewares/#optional-middleware","title":"Optional middleware","text":"<p>In some cases, like in development, you'll have a middleware that is not always existing. The framework deals with this case via composition with the <code>Optional</code> middleware.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Application,\n    Middleware\\Optional,\n};\n\nnew class extends Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;map(Optional::of(MyMiddleware::class));\n    }\n};\n</code></pre> <p>If the <code>MyMiddleware</code> class doesn't exist it will do nothing and if it exists it will instanciate it and call it.</p> <p>If the middleware constructor is private or you want to specify arguments you can pass a factory as a second argument like this:</p> <pre><code>Optional::of(\n    MyMiddleware::class,\n    static fn() =&gt; new MyMiddleware('some argument'),\n);\n</code></pre>"},{"location":"operating-system/","title":"Decorate the operating system","text":"<p>The framework exposes an instance of <code>OperatingSystem</code> in various methods of <code>Application</code> offering you a wide range of abstractions. You can enhance its capabilities by adding a decorator on top of it.</p> <p>For example <code>innmind/operating-system</code> comes with a decorator that use an exponential backoff strategy for the http client.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Cli,\n    Main\\Http,\n    Application,\n};\nuse Innmind\\OperatingSystem\\{\n    OperatingSystem,\n    Config\\Resilient,\n};\n\nnew class extends Http|Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;mapOperatingSystem(\n            static fn(OperatingSystem $os) =&gt; $os-&gt;map(Resilient::new()),\n        );\n    }\n};\n</code></pre> <p>Now everything that relies on <code>$os-&gt;remote()-&gt;http()</code> will use this exponential backoff strategy.</p>"},{"location":"services/","title":"Services","text":"<p>For both HTTP and CLI applications a service is an object referenced by a name in a <code>Container</code>.</p>"},{"location":"services/#defining-a-service","title":"Defining a service","text":"<pre><code>use Innmind\\DI\\Service;\nuse Innmind\\AMQP\\Client;\n\n/**\n * @template S of object\n * @implements Service&lt;S&gt;\n */\nenum Services implements Service\n{\n    case amqpClient;\n    case producerClient;\n    case consumerClient;\n\n    /**\n     * @return self&lt;Client&gt;\n     */\n    public static function amqpClient(): self\n    {\n        /** @var self&lt;Client&gt; */\n        return self::amqpClient;\n    }\n\n    /**\n     * @return self&lt;Client&gt;\n     */\n    public static function producerClient(): self\n    {\n        /** @var self&lt;Client&gt; */\n        return self::producerClient;\n    }\n\n    /**\n     * @return self&lt;Client&gt;\n     */\n    public static function consumerClient(): self\n    {\n        /** @var self&lt;Client&gt; */\n        return self::consumerClient;\n    }\n}\n</code></pre> <p>If you publish a package you can add an <code>@internal</code> flag on the static methods to tell your users to not use the service. And when you plan to remove a service you can use the <code>@deprecated</code> flag.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Main\\Cli,\n    Application,\n};\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\AMQP\\Factory;\nuse Innmind\\IO\\Sockets\\Internet\\Transport;\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Url\\Url;\n\nnew class extends Http|Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;service(\n            Services::amqpClient(),\n            static fn($_, OperatingSystem $os) =&gt; Factory::of($os)-&gt;make(\n                Transport::tcp(),\n                Url::of('amqp://guest:guest@localhost:5672/'),\n                Period::second(1),\n            ),\n        );\n    }\n};\n</code></pre> <p>This example defines a single service named <code>amqpClient</code> that relies on the <code>OperatingSystem</code> in order to work.</p> <p>This example uses <code>innmind/amqp</code>.</p>"},{"location":"services/#configure-via-environment-variables","title":"Configure via environment variables","text":"<p>In the previous example we defined an AMQP client with a hardcoded url for the server and timeout, but you may want to configure those with environment variables.</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Main\\Cli,\n    Application,\n    Environment,\n};\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\AMQP\\Factory;\nuse Innmind\\IO\\Sockets\\Internet\\Transport;\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Url\\Url;\n\nnew class extends Http|Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app-&gt;service(\n            Services::amqpClient(),\n            static fn(\n                $_,\n                OperatingSystem $os,\n                Environment $env\n            ) =&gt; Factory::of($os)-&gt;make(\n                Transport::tcp(),\n                Url::of($env-&gt;get('AMQP_URL')), //(1)\n                Period::second($env-&gt;maybe('AMQP_TIMEOUT')-&gt;match( //(2)\n                    static fn($timeout) =&gt; (int) $timeout,\n                    static fn() =&gt; 1,\n                )),\n            ),\n        );\n    }\n};\n</code></pre> <ol> <li>this will throw if the variable is not defined</li> <li>in case the variable is not defined it will fallback to a <code>1s</code> timeout</li> </ol>"},{"location":"services/#services-relying-on-services","title":"Services relying on services","text":"<p>If we continue with our AMQP example, in an application that both produces and consumes messages (with high throughput) we'll want 2 different clients. One basic client (like previous examples) for producing messages and one client where we configure the number of messages to prefetch.</p> <p>To do this we'll reuse our previous service definition and define a new one that calls the first one. (This operation is safe in this case as the client is immutable)</p> <pre><code>use Innmind\\Framework\\{\n    Main\\Http,\n    Main\\Cli,\n    Application,\n};\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\DI\\Container;\nuse Innmind\\AMQP\\{\n    Factory,\n    Command\\Qos,\n};\n\nnew class extends Http|Cli {\n    protected function configure(Application $app): Application\n    {\n        return $app\n            -&gt;service(\n                Services::producerClient(),\n                static fn($_, OperatingSystem $os) =&gt; Factory::of($os)-&gt;make(/* like above */),\n            )\n            -&gt;service(\n                Services::consumerClient(),\n                static fn(Container $container) =&gt; $container(Services::producerClient)-&gt;with(\n                    Qos::of(10), // prefetch 10 messages\n                ),\n            );\n    }\n};\n</code></pre> <p>Now every other service that relies on <code>consumerClient</code> will always have a configuration to prefetch 10 messages.</p>"},{"location":"testing/","title":"Testing","text":"<p>The best way to test your application is to move the whole configuration inside a middleware that you can then reference in your tests.</p> <p>If your whole app is contained in a middleware called <code>Kernel</code> and you use PHPUnit your test could look like this:</p>"},{"location":"testing/#for-http","title":"For HTTP","text":"<pre><code>use Innmind\\Framework\\{\n    Application,\n    Environment,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\nuse PHPUnit\\Framework\\TestCase;\n\nfinal class AppTest extends TestCase\n{\n    public function testIndex()\n    {\n        $os = Factory::build(); // or use mocks\n        $app = Application::http($os, Environment::test([\n            'AMQP_URL' =&gt; 'amqp://guest:guest@localhost:5672/',\n        ]))-&gt;map(new Kernel);\n\n        $response = $app-&gt;run(ServerRequest::of(\n            Url::of('/'),\n            Method::get,\n            ProtocolVersion::v20,\n        ))-&gt;unwrap();\n\n        // $response is an instance of Response\n        // write your assertions as usual\n    }\n}\n</code></pre>"},{"location":"testing/#for-cli","title":"For CLI","text":"<pre><code>use Innmind\\Framework\\{\n    Application,\n    Environment,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\CLI\\Environment\\InMemory;\nuse PHPUnit\\Framework\\TestCase;\n\nfinal class AppTest extends TestCase\n{\n    public function testIndex()\n    {\n        $variables = [\n            ['AMQP_URL', 'amqp://guest:guest@localhost:5672/'],\n        ];\n        $os = Factory::build(); // or use mocks\n        $app = Application::cli($os, Environment::test($variables))-&gt;map(\n            new Kernel,\n        );\n\n        $environment = $app-&gt;run(InMemory::of(\n            [], // input chunks\n            false, // interactive\n            ['entrypoint.php'], // arguments\n            $variables,\n            '/somewhere/', // working directory\n        ))-&gt;unwrap();\n\n        $this-&gt;assertSame(\n            [],\n            $environment-&gt;outputs()\n        );\n        $this-&gt;assertNull($environment-&gt;exitCode()-&gt;match(\n            static fn($exitCode) =&gt; $exitCode-&gt;toInt(),\n            static fn() =&gt; null,\n        ));\n    }\n}\n</code></pre>"},{"location":"testing/#extending-behaviour","title":"Extending behaviour","text":"<p>Since we use a declarative approach and that <code>Application</code> is immutable we can extend the behaviour of our app in our tests.</p> <p>Say we want to write functional tests but we have a route that deletes data in a database but we can't verify the data is deleted through our routes. We can add a call to <code>mapRoute</code> so we are in the context of our app and we can inject the test case to write our assertions.</p> <pre><code>use Innmind\\Framework\\{\n    Application,\n    Environment,\n};\nuse Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Router\\Component;\nuse Innmind\\Http\\{\n    ServerRequest,\n    Response,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\Immutable\\Attempt;\nuse PHPUnit\\Framework\\TestCase;\n\nfinal class AppTest extends TestCase\n{\n    public function testIndex()\n    {\n        $os = Factory::build(); // or use mocks\n        $app = Application::http($os, Environment::test([\n            'AMQP_URL' =&gt; 'amqp://guest:guest@localhost:5672/',\n        ]))\n            -&gt;map(new Kernel)\n            -&gt;mapRoute(static fn($route, $container) =&gt; $route-&gt;pipe(\n                Component::of(function($request, $response) use ($container) {\n                    $this-&gt;assertSame(\n                        [],\n                        $container(Services::pdo)\n                            -&gt;query('SELECT * FROM some_column WHERE condition_that_should_return_nothing')\n                            -&gt;fetchAll(),\n                    );\n\n                    return Attempt::result($response);\n                }),\n            ));\n\n        $response = $app-&gt;run(ServerRequest::of(\n            Url::of('/some-route/some-id'),\n            Method::delete,\n            ProtocolVersion::v20,\n        ))-&gt;unwrap();\n\n        // $response is an instance of Response\n        // write your assertions as usual\n    }\n}\n</code></pre>"},{"location":"experimental/async-server/","title":"Async HTTP Server","text":"<p>The framework comes with an HTTP server entirely built in PHP allowing you to serve your app without extra dependencies in ther earlist stages of your project.</p> <p>This feature is optional, to use it you must before run <code>composer require innmind/async-http-server</code>.</p> <p>To use it is similar to the standard http handler, the first difference is the namespace of the main entrypoint:</p> index.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/composer/autoload.php';\n\nuse Innmind\\Framework\\{\n    Main\\Async\\Http,\n    Application,\n};\n\nnew class extends Http {\n    protected function configure(Application $app): Application\n    {\n        return $app;\n    }\n};\n</code></pre> <p>Note the namespace is <code>Main\\Async\\Http</code> instead of <code>Main\\Http</code>. The other difference is instead of pointing your HTTP Server to the folder containing the php file you run the server via <code>php index.php</code>.</p> <p>All the configuration of the <code>Application</code> object is identical to the other contexts.</p> <p>The server currently does have limitations, streamed requests (via <code>Transfer-Encoding</code>) are not supported and multipart requests are not parsed.</p> <p>This server was built to showcase in a conference talk the ability to switch between synchronous code and asynchronous code without changing the app code. Do NOT use this server in production.</p>"}]}